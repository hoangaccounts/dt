#!/usr/bin/env bash
# dt — tiny devtools launcher
#
# Contract (v0.0.1)
# - Discovers tools by scanning ./tools for executables that contain a valid help header.
# - A valid header starts at line 1 and ends at the marker: '### END HELP'.
# - Required header keys: VERSION, SUMMARY, TAGS, SYNOPSIS, SAFETY
#
# Commands:
#   dt               Show dt help.
#   dt help [tool]   Show dt help or tool help.
#   dt list          List all valid tools.
#   dt tags          List approved tags and counts.
#   dt list -t <tag> List tools that have <tag>.
#   dt <tool>        Show help for <tool>.
#   dt <tool> ...    Run <tool> with args passed through.
#   dt install       Symlink this dt into ~/.local/bin/dt (no tool symlinks).
#   dt uninstall     Remove ~/.local/bin/dt if it is a symlink (prompts).
#   dt test          Run Bats tests (requires bats in PATH).
set -euo pipefail

DT_VERSION="0.0.1"

# Resolve the *real* path of this script even when invoked via a symlink.
#
# Why:
# - `dt install` places a symlink at ~/.local/bin/dt.
# - If we compute paths from $0 / BASH_SOURCE[0] directly, we may incorrectly
#   treat ~/.local/bin as the repo root, breaking commands like `dt test`.
#
# Design:
# - Prefer python3 for a reliable realpath implementation.
# - Fall back to a readlink loop.
resolve_dt_self_path() {
  # macOS ships Bash 3.2, so avoid Bash-4 features here.
  #
  # We need a *real* path to this script because `dt install` uses a symlink at
  # ~/.local/bin/dt. When invoked via that symlink, $0 / BASH_SOURCE[0] often
  # reflect the symlink path. For repo-relative operations (tools/, test/, docs),
  # we must follow the symlink to the real file.
  local invoked="${BASH_SOURCE[0]}"

  # If invoked is not a path (e.g., just "dt"), resolve via PATH.
  if [[ "${invoked}" != *"/"* ]]; then
    local resolved_from_path
    resolved_from_path="$(command -v "${invoked}" 2>/dev/null || true)"
    if [[ -n "${resolved_from_path}" ]]; then
      invoked="${resolved_from_path}"
    fi
  fi

  # Follow symlinks manually (portable; no readlink -f on macOS).
  while [[ -L "${invoked}" ]]; do
    local link
    link="$(readlink "${invoked}")"
    if [[ "${link}" == /* ]]; then
      invoked="${link}"
    else
      local link_dir
      link_dir="$(cd -P "$(dirname "${invoked}")" && pwd -P)"
      invoked="${link_dir}/${link}"
    fi
  done

  # Normalize to an absolute, physical path.
  if [[ "${invoked}" != /* ]]; then
    invoked="$(cd -P "$(dirname "${invoked}")" && pwd -P)/$(basename "${invoked}")"
  fi

  echo "${invoked}"
}

SCRIPT_DIR="$(cd -P "$(dirname "$(resolve_dt_self_path)")" && pwd -P)"
TOOLS_DIR="${SCRIPT_DIR}/tools"
LOCAL_BIN="${HOME}/.local/bin"
DT_LINK="${LOCAL_BIN}/dt"

# Strict, opinionated tag vocabulary (v1).
readonly -a APPROVED_TAGS=(
  "share" "git" "shell" "env" "project" "net" "files"
  "android" "ios" "web" "node" "python" "kotlin" "flutter"
  "misc"
)

print_dt_help() {
  cat <<'EOF'
dt — a tiny launcher for self-documented developer tools.

Usage:
  dt
  dt -help
  dt help
  dt help <tool>
  dt list
  dt -list
  dt list -t <tag>
  dt tags
  dt -tags
  dt <tool>
  dt <tool> [args...]
  dt <alias> [args...]   (tool shortcut, if defined)
  dt install   (or: dt -install)
  dt uninstall (or: dt -uninstall)
  dt test      (or: dt -test)

Notes:
- Tools live in ./tools and are discovered automatically (no registry).
- Each tool must be executable and start with a valid header that ends with:
    ### END HELP
- dt <tool> (no args) prints tool help (safe by default).
- Tools may define short aliases (e.g., 'git-aliases' → 'ga'); run 'dt list' to see them.
- dt <tool> <...> runs the tool and passes args through.

Examples:
  dt list
  dt tags
  dt list -t git
  dt help git-aliases
  dt git-aliases list
  dt ga list
  dt git-aliases install
  dt test
EOF
}

normalize_cmd() {
  # Provide a very small, user-friendly flag alias set so first-time users can
  # type `dt -install` and move on.
  #
  # This is intentionally limited — we do not want dt to grow a large flags
  # surface area.
  local raw="$1"
  case "${raw}" in
  -help|--help|-h)
    echo "help"
    ;;
  -version|--version)
    echo "version"
    ;;
  -list|--list)
    echo "list"
    ;;
  -tags|--tags)
    echo "tags"
    ;;
  -install|--install)
    echo "install"
    ;;
  -uninstall|--uninstall)
    echo "uninstall"
    ;;
  -test|--test)
    echo "test"
    ;;
  *)
    echo "${raw}"
    ;;
  esac
}

is_approved_tag() {
  local candidate="$1"
  local t
  for t in "${APPROVED_TAGS[@]}"; do
    if [[ "${t}" == "${candidate}" ]]; then
      return 0
    fi
  done
  return 1
}

tool_path() {
  local tool="$1"
  echo "${TOOLS_DIR}/${tool}"
}


trim_ws() {
  local s="${1}"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  echo "${s}"
}

is_reserved_dt_command() {
  # If a tool claims an alias that matches a dt built-in command, the alias would
  # never be reachable. Treat these as reserved and ignore them.
  local candidate="${1}"
  case "${candidate}" in
  help|version|list|tags|install|uninstall|test)
    return 0
    ;;
  *)
    return 1
    ;;
  esac
}

alias_winner_from_csv() {
  # Input: comma-separated tool ids. Output: deterministic winner.
  # Policy: lexical order (stable, predictable across machines).
  local csv="${1}"
  local -a parts=()
  IFS=',' read -r -a parts <<<"${csv}"

  local winner=""
  local p
  for p in "${parts[@]}"; do
    p="$(trim_ws "${p}")"
    [[ -n "${p}" ]] || continue
    if [[ -z "${winner}" || "${p}" < "${winner}" ]]; then
      winner="${p}"
    fi
  done

  echo "${winner}"
}

resolve_tool_alias() {
  # Given an alias like 'ga', find the tool id that owns it.
  # If multiple tools claim the same alias, pick a deterministic winner.
  local alias="${1}"

  local -a matches=()
  local f tool aliases_line
  local -a aliases_raw
  local a trimmed

  for f in "${TOOLS_DIR}"/*; do
    [[ -e "${f}" ]] || continue
    [[ -f "${f}" ]] || continue
    [[ -x "${f}" ]] || continue
    has_valid_header "${f}" || continue

    tool="$(basename "${f}")"
    aliases_line="$(read_header_value "${f}" "ALIASES")"
    [[ -n "${aliases_line}" ]] || continue

    IFS=',' read -r -a aliases_raw <<<"${aliases_line}"
    for a in "${aliases_raw[@]}"; do
      trimmed="$(trim_ws "${a}")"
      [[ -n "${trimmed}" ]] || continue
      is_reserved_dt_command "${trimmed}" && continue
      [[ "${trimmed}" == "${alias}" ]] || continue
      matches+=("${tool}")
    done
  done

  if [[ "${#matches[@]}" -eq 0 ]]; then
    return 1
  fi

  local winner="${matches[0]}"
  local m
  for m in "${matches[@]}"; do
    if [[ "${m}" < "${winner}" ]]; then
      winner="${m}"
    fi
  done

  if [[ "${#matches[@]}" -gt 1 ]]; then
    echo "Alias conflict for '${alias}': ${matches[*]} — using '${winner}'." >&2
  fi

  echo "${winner}"
}

has_valid_header() {
  local file="$1"

  local header
  header="$(awk '
    # Tools keep a man-style header as commented lines at the top of the file.
    # We strip a single leading "#" (and an optional following space) so the
    # header is readable and easy to parse.
    NR==1 && /^#!/ { next }
    /^### END HELP$/ { print "### END HELP"; exit }
    {
      line=$0
      sub(/^#[[:space:]]?/, "", line)
      print line
    }
  ' "${file}" 2>/dev/null || true)"

  [[ -n "${header}" ]] || return 1
  grep -q "^VERSION:" <<<"${header}" || return 1
  grep -q "^SUMMARY:" <<<"${header}" || return 1
  grep -q "^TAGS:" <<<"${header}" || return 1
  grep -q "^SYNOPSIS:" <<<"${header}" || return 1
  grep -q "^SAFETY:" <<<"${header}" || return 1
  grep -q "^### END HELP$" <<<"${header}" || return 1
  return 0
}

read_header_value() {
  local file="$1"
  local key="$2"
  awk -v k="${key}:" '
    NR==1 && /^#!/ { next }
    /^### END HELP$/ { exit }
    {
      line=$0
      sub(/^#[[:space:]]?/, "", line)
    }
    line ~ "^" k {
      sub("^" k "[[:space:]]*", "", line)
      print line
      exit
    }
  ' "${file}" 2>/dev/null || true
}

print_tool_help() {
  local tool="$1"
  local file
  file="$(tool_path "${tool}")"

  if [[ ! -f "${file}" ]]; then
    echo "Unknown tool: ${tool}" >&2
    exit 2
  fi

  if [[ ! -x "${file}" ]]; then
    echo "Tool exists but is not executable: ${tool}" >&2
    exit 2
  fi

  if ! has_valid_header "${file}"; then
    echo "Tool is missing a valid header: ${tool}" >&2
    echo "Required: VERSION, SUMMARY, TAGS, SYNOPSIS, SAFETY, and '### END HELP' marker." >&2
    exit 2
  fi

  awk '
    NR==1 && /^#!/ { next }
    /^### END HELP$/ { print "### END HELP"; exit }
    {
      line=$0
      sub(/^#[[:space:]]?/, "", line)
      print line
    }
  ' "${file}"
}

list_tools() {
  local filter_tag="${1:-}"
  local -a invalid=()
  local -a rows=()

  # Track alias usage to surface conflicts in `dt list`.
  local -a alias_keys=()
  local -a alias_values=()
  local -a reserved_aliases=()

  if [[ ! -d "${TOOLS_DIR}" ]]; then
    echo "Missing tools directory: ${TOOLS_DIR}" >&2
    exit 2
  fi

  add_alias_mapping() {
    # alias_keys[i]   = alias
    # alias_values[i] = comma-separated tool IDs
    local alias="${1}"
    local tool="${2}"
    local i

    for i in "${!alias_keys[@]}"; do
      if [[ "${alias_keys[$i]}" == "${alias}" ]]; then
        # Avoid duplicates.
        case "${alias_values[$i]}" in
        *",${tool},"*|"${tool},"*|*",${tool}"*|"${tool}")
          return 0
          ;;
        esac
        alias_values[$i]="${alias_values[$i]},${tool}"
        return 0
      fi
    done

    alias_keys+=("${alias}")
    alias_values+=("${tool}")
  }

  local f tool version summary tags_line aliases_line
  local -a tags_raw aliases_raw
  local tag ok a

  for f in "${TOOLS_DIR}"/*; do
    [[ -e "${f}" ]] || continue
    [[ -f "${f}" ]] || continue
    [[ -x "${f}" ]] || continue

    tool="$(basename "${f}")"

    if ! has_valid_header "${f}"; then
      invalid+=("${tool}")
      continue
    fi

    version="$(read_header_value "${f}" "VERSION")"
    summary="$(read_header_value "${f}" "SUMMARY")"
    tags_line="$(read_header_value "${f}" "TAGS")"
    aliases_line="$(read_header_value "${f}" "ALIASES")"

    IFS=',' read -r -a tags_raw <<<"${tags_line}"
    ok=1
    for tag in "${tags_raw[@]}"; do
      tag="$(trim_ws "${tag}")"
      [[ -n "${tag}" ]] || continue
      if ! is_approved_tag "${tag}"; then
        ok=0
        break
      fi
    done

    if [[ "${ok}" -eq 0 ]]; then
      invalid+=("${tool}")
      continue
    fi

    if [[ -n "${filter_tag}" ]]; then
      local has_tag=0
      for tag in "${tags_raw[@]}"; do
        tag="$(trim_ws "${tag}")"
        if [[ "${tag}" == "${filter_tag}" ]]; then
          has_tag=1
          break
        fi
      done
      [[ "${has_tag}" -eq 1 ]] || continue
    fi

    local alias_display=""
    if [[ -n "${aliases_line}" ]]; then
      IFS=',' read -r -a aliases_raw <<<"${aliases_line}"
      local -a clean_aliases=()
      for a in "${aliases_raw[@]}"; do
        a="$(trim_ws "${a}")"
        [[ -n "${a}" ]] || continue

        if is_reserved_dt_command "${a}"; then
          reserved_aliases+=("${tool}:${a}")
          continue
        fi

        clean_aliases+=("${a}")
        add_alias_mapping "${a}" "${tool}"
      done

      if [[ "${#clean_aliases[@]}" -gt 0 ]]; then
        alias_display="[${clean_aliases[0]}"
        local i
        for i in "${!clean_aliases[@]}"; do
          if [[ "${i}" -eq 0 ]]; then
            continue
          fi
          alias_display="${alias_display},${clean_aliases[$i]}"
        done
        alias_display="${alias_display}]"
      fi
    fi

    if [[ -n "${alias_display}" ]]; then
      rows+=("${tool} ${alias_display} (v${version}) — ${summary}")
    else
      rows+=("${tool} (v${version}) — ${summary}")
    fi
  done

  if [[ "${#rows[@]}" -gt 0 ]]; then
    printf "%s
" "${rows[@]}" | sort
  else
    if [[ -n "${filter_tag}" ]]; then
      echo "No tools tagged '${filter_tag}'."
    else
      echo "No valid tools found."
    fi
  fi

  if [[ "${#invalid[@]}" -gt 0 ]]; then
    echo
    echo "Invalid tools (missing header / invalid tags / not executable):"
    printf "  - %s
" "${invalid[@]}" | sort
  fi

  # Surface alias conflicts.
  local i
  local printed=0
  for i in "${!alias_keys[@]}"; do
    case "${alias_values[$i]}" in
    *,*)
      if [[ "${printed}" -eq 0 ]]; then
        echo
        echo "Alias conflicts (winner = lexicographically smallest tool id):"
        printed=1
      fi
      local -a candidates=()
      IFS=',' read -r -a candidates <<<"${alias_values[$i]}"
      local winner="${candidates[0]}"
      local c
      for c in "${candidates[@]}"; do
        if [[ "${c}" < "${winner}" ]]; then
          winner="${c}"
        fi
      done
      printf "  - %s: %s -> %s
" "${alias_keys[$i]}" "${alias_values[$i]}" "${winner}"
      ;;
    esac
  done

  if [[ "${#reserved_aliases[@]}" -gt 0 ]]; then
    echo
    echo "Ignored reserved aliases (dt built-ins win):"
    printf "  - %s
" "${reserved_aliases[@]}" | sort
  fi
}



list_tags() {
  # Bash 3.2 (macOS default) does not support associative arrays.
  # Keep this compatible by using parallel indexed arrays.
  local -a counts=()
  local i
  for i in "${!APPROVED_TAGS[@]}"; do
    counts[$i]=0
  done

  local f tags_line
  local -a tags_raw
  local tag trimmed

  for f in "${TOOLS_DIR}"/*; do
    [[ -e "${f}" ]] || continue
    [[ -f "${f}" ]] || continue
    [[ -x "${f}" ]] || continue
    has_valid_header "${f}" || continue

    tags_line="$(read_header_value "${f}" "TAGS")"
    IFS=',' read -r -a tags_raw <<<"${tags_line}"

    for tag in "${tags_raw[@]}"; do
      trimmed="${tag#"${tag%%[![:space:]]*}"}"
      trimmed="${trimmed%"${trimmed##*[![:space:]]}"}"
      [[ -n "${trimmed}" ]] || continue

      # Find the tag index in APPROVED_TAGS.
      for i in "${!APPROVED_TAGS[@]}"; do
        if [[ "${APPROVED_TAGS[$i]}" == "${trimmed}" ]]; then
          counts[$i]=$((counts[$i] + 1))
          break
        fi
      done
    done
  done

  for i in "${!APPROVED_TAGS[@]}"; do
    printf "%-10s %d
" "${APPROVED_TAGS[$i]}" "${counts[$i]}"
  done
}

ensure_local_bin_on_path() {
  # If ~/.local/bin is already on PATH, nothing to do.
  if [[ ":${PATH}:" == *":${LOCAL_BIN}:"* ]]; then
    return 0
  fi

  echo
  echo "Note: '${LOCAL_BIN}' is not currently on PATH."

  # If we're not in an interactive TTY, we cannot prompt. Just print instructions.
  if [[ ! -t 0 ]]; then
    echo "Add this to your shell profile (e.g., ~/.zshrc or ~/.bashrc):"
    echo "  export PATH=\"${LOCAL_BIN}:\$PATH\""
    return 0
  fi

  echo "Would you like me to add it to your shell profile now? [y/N]"
  read -r reply || true
  if [[ ! "${reply}" =~ ^[Yy]$ ]]; then
    echo "Ok — not modifying your shell profile."
    echo "Add this line to your shell profile (e.g., ~/.zshrc or ~/.bashrc):"
    echo "  export PATH=\"${LOCAL_BIN}:\$PATH\""
    return 0
  fi

  local shell_name profile
  shell_name="$(basename "${SHELL:-}")"
  profile=""

  case "${shell_name}" in
  zsh)
    profile="${HOME}/.zshrc"
    ;;
  bash)
    if [[ -f "${HOME}/.bashrc" ]]; then
      profile="${HOME}/.bashrc"
    else
      profile="${HOME}/.bash_profile"
    fi
    ;;
  *)
    profile=""
    ;;
  esac

  if [[ -z "${profile}" ]]; then
    echo "I couldn't detect a supported shell profile for SHELL='${SHELL:-}'."
    echo "Please add this line manually:"
    echo "  export PATH=\"${LOCAL_BIN}:\$PATH\""
    return 0
  fi

  # Idempotent: avoid duplicating the block if it already exists.
  if grep -q "dt-devtools: add ~/.local/bin to PATH" "${profile}" 2>/dev/null; then
    echo "Looks like PATH setup already exists in ${profile}."
    echo "Restart your terminal (or 'source ${profile}') to apply."
    return 0
  fi

  {
    echo
    echo "# dt-devtools: add ~/.local/bin to PATH (added by 'dt install')"
    echo "export PATH=\"${HOME}/.local/bin:\$PATH\""
  } >> "${profile}"

  echo "Updated: ${profile}"
  echo "Restart your terminal (or run: source ${profile}) to apply."
}


fix_repo_permissions() {
  # Zip extraction on macOS can strip executable bits. Make install resilient by
  # restoring +x on dt, bootstrap, and tools/* when possible.
  chmod +x "${SCRIPT_DIR}/dt" 2>/dev/null || true
  chmod +x "${SCRIPT_DIR}/bootstrap" 2>/dev/null || true
  if [[ -d "${TOOLS_DIR}" ]]; then
    chmod +x "${TOOLS_DIR}/"* 2>/dev/null || true
  fi
}

install_dt() {
  # Install should be ergonomic for first-time users:
  # 1) Ensure ~/.local/bin is on PATH (offer to add to shell profile).
  # 2) Create/replace the ~/.local/bin/dt symlink.
  #
  # IMPORTANT: We do PATH setup first so the user gets the prompt even when a
  # symlink already exists.

  local force=0
  if [[ "${#}" -ge 1 ]]; then
    case "${1}" in
    --force|-f)
      force=1
      shift || true
      ;;
    esac
  fi

  mkdir -p "${LOCAL_BIN}"
  ensure_local_bin_on_path
  fix_repo_permissions

  local target="${SCRIPT_DIR}/dt"
  [[ -f "${target}" ]] || target="${BASH_SOURCE[0]}"

  if [[ -L "${DT_LINK}" ]]; then
    local existing
    existing="$(readlink "${DT_LINK}")"

    if [[ "${existing}" == "${target}" ]]; then
      echo "dt is already installed at ${DT_LINK}"
      return 0
    fi

    if [[ "${force}" -eq 0 ]]; then
      if [[ ! -t 0 ]]; then
        echo "Refusing to overwrite existing symlink at ${DT_LINK} -> ${existing}" >&2
        echo "Re-run with: ./dt install --force" >&2
        exit 2
      fi

      echo "An existing dt symlink was found:"
      echo "  ${DT_LINK} -> ${existing}"
      echo "Replace it to point to this repo?"
      echo "  ${DT_LINK} -> ${target}"
      echo "Proceed? [y/N]"
      local reply
      read -r reply || true
      if [[ ! "${reply}" =~ ^[Yy]$ ]]; then
        echo "Ok — not changing the existing symlink."
        echo "Tip: You can remove it manually: rm ${DT_LINK}"
        exit 2
      fi
    fi

    rm "${DT_LINK}"
  elif [[ -e "${DT_LINK}" ]]; then
    # Not a symlink (could be a real file). We won't overwrite this by default.
    echo "Refusing to overwrite existing file at ${DT_LINK}" >&2
    echo "Remove it manually, then re-run: ./dt install" >&2
    exit 2
  fi

  ln -s "${target}" "${DT_LINK}"
  echo "Installed: ${DT_LINK} -> ${target}"
}

uninstall_dt() {
  # Uninstall is intentionally conservative: only remove what is clearly a dt
  # symlink, and never delete non-symlink files.
  local force=0
  if [[ "${#}" -ge 1 ]]; then
    case "${1}" in
    --force|-f|--yes)
      force=1
      shift || true
      ;;
    esac
  fi

  if [[ -L "${DT_LINK}" ]]; then
    local existing
    existing="$(readlink "${DT_LINK}")"

    if [[ "${force}" -eq 0 && -t 0 ]]; then
      echo "Found dt symlink:"
      echo "  ${DT_LINK} -> ${existing}"
      echo "Remove it? [y/N]"
      local reply
      read -r reply || true
      if [[ ! "${reply}" =~ ^[Yy]$ ]]; then
        echo "Ok — not removing the symlink."
        exit 2
      fi
    elif [[ "${force}" -eq 0 && ! -t 0 ]]; then
      echo "Refusing to remove ${DT_LINK} in non-interactive mode." >&2
      echo "Re-run with: dt uninstall --force" >&2
      exit 2
    fi

    rm "${DT_LINK}"
    echo "Removed: ${DT_LINK}"
    return 0
  fi

  if [[ -e "${DT_LINK}" ]]; then
    echo "Refusing to remove ${DT_LINK} (not a symlink)" >&2
    exit 2
  fi

  echo "dt is not installed at ${DT_LINK}"
}

run_tests() {
  local test_dir="${SCRIPT_DIR}/test"
  if [[ ! -d "${test_dir}" ]]; then
    echo "Missing test directory: ${test_dir}" >&2
    exit 2
  fi

  if ! command -v bats >/dev/null 2>&1; then
    echo "bats is required to run tests." >&2

    # Keep the default behavior safe and deterministic: never auto-install dependencies
    # unless the user explicitly opts in via an interactive prompt.
    if command -v brew >/dev/null 2>&1 && [[ -t 0 ]]; then
      echo "Homebrew detected." >&2
      echo "Install bats-core now? This will run: brew install bats-core" >&2
      printf "Install bats-core? [y/N] " >&2
      local reply=""
      IFS= read -r reply || true
      if [[ "${reply}" =~ ^[Yy]$ ]]; then
        if ! brew install bats-core; then
          echo "Failed to install bats-core via Homebrew." >&2
          exit 2
        fi
      fi
    fi

    if ! command -v bats >/dev/null 2>&1; then
      echo "Install bats-core (https://github.com/bats-core/bats-core) and re-run:" >&2
      if command -v brew >/dev/null 2>&1; then
        echo "  brew install bats-core" >&2
      fi
      echo "  dt test" >&2
      exit 2
    fi
  fi

  bats "${test_dir}"
}

main() {
  if [[ "${#}" -eq 0 ]]; then
    print_dt_help
    exit 0
  fi

  local cmd="${1}"
  cmd="$(normalize_cmd "${cmd}")"
  shift || true

  case "${cmd}" in
  help|-h|--help)
    if [[ "${#}" -eq 0 ]]; then
      print_dt_help
    else
      local requested="${1}"
      if [[ ! -f "$(tool_path "${requested}")" ]]; then
        local resolved
        resolved="$(resolve_tool_alias "${requested}" 2>/dev/null || true)"
        if [[ -n "${resolved}" ]]; then
          requested="${resolved}"
        fi
      fi
      print_tool_help "${requested}"
    fi
    ;;
  version|--version)
    echo "dt v${DT_VERSION}"
    ;;
  list)
    if [[ "${#}" -ge 2 && "${1}" == "-t" ]]; then
      local tag="${2}"
      if ! is_approved_tag "${tag}"; then
        echo "Unknown tag: ${tag}" >&2
        echo "Run: dt tags" >&2
        exit 2
      fi
      list_tools "${tag}"
    else
      list_tools
    fi
    ;;
  tags)
    list_tags
    ;;
  install)
  # Bash 3.2 + `set -u` can treat an empty "$@" expansion as an
  # unbound special parameter. Avoid expanding when there are no args.
    if [[ "$#" -gt 0 ]]; then
      install_dt "$@"
    else
      install_dt
    fi
    ;;
  uninstall)
  # Same compatibility guard as install.
    if [[ "$#" -gt 0 ]]; then
      uninstall_dt "$@"
    else
      uninstall_dt
    fi
    ;;
  test)
    run_tests
    ;;
  *)
    local tool="${cmd}"
    local file
    file="$(tool_path "${tool}")"
    if [[ ! -f "${file}" ]]; then
      local resolved
      resolved="$(resolve_tool_alias "${tool}" || true)"
      if [[ -n "${resolved}" ]]; then
        tool="${resolved}"
        file="$(tool_path "${tool}")"
      fi
    fi

    if [[ ! -f "${file}" ]]; then
      echo "Unknown command or tool: ${tool}" >&2
      echo "Run: dt help" >&2
      exit 2
    fi

    if [[ "${#}" -eq 0 ]]; then
      print_tool_help "${tool}"
      exit 0
    fi

    exec "${file}" "${@}"
    ;;
  esac
}

main "$@"
